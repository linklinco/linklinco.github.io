{"title": "一些可能有用的代码", "topic": null, "time": "2025-04-05 20:37:10", "label": [], "needPassword": false, "text": "\n### 常见headers\n懒得写，把之前写的爬虫headers贴在这里方便复制\n\n```python\n    headers = {\n        'Host':'dianying.nuomi.com',\n        'Connection':'keep-alive',\n        'Content-Length': '27',\n        'Sec-Fetch-Mode': 'cors',\n        'Origin': 'https://dianying.nuomi.com',\n        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.132 Safari/537.36',\n        'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8',\n        'Accept': 'application/json, text/javascript, */*; q=0.01',\n        'X-Requested-With': 'XMLHttpRequest',\n        'DNT': '1',\n        'Sec-Fetch-Site': 'same-origin',\n        'Referer': 'https://dianying.nuomi.com/movie/boxoffice?cityId=218',\n        'Accept-Encoding': 'gzip, deflate, br',\n        'Accept-Language': 'zh-CN,zh;q=0.9'\n    }\n```\n\n\n### 随机UA\n\n```python\nmy_headers = [\n    \"Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.95 Safari/537.36\",\n    \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.1916.153 Safari/537.36\",\n    \"Mozilla/5.0 (Windows NT 6.1; WOW64; rv:30.0) Gecko/20100101 Firefox/30.0\",\n    \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_2) AppleWebKit/537.75.14 (KHTML, like Gecko) Version/7.0.3 Safari/537.75.14\",\n    \"Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.2; Win64; x64; Trident/6.0)\",\n    'Mozilla/5.0 (Windows; U; Windows NT 5.1; it; rv:1.8.1.11) Gecko/20071127 Firefox/2.0.0.11',\n    'Opera/9.25 (Windows NT 5.1; U; en)',\n    'Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 1.1.4322; .NET CLR 2.0.50727)',\n    'Mozilla/5.0 (compatible; Konqueror/3.5; Linux) KHTML/3.5.5 (like Gecko) (Kubuntu)',\n    'Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.8.0.12) Gecko/20070731 Ubuntu/dapper-security Firefox/1.5.0.12',\n    'Lynx/2.8.5rel.1 libwww-FM/2.14 SSL-MM/1.4.1 GNUTLS/1.2.9',\n    \"Mozilla/5.0 (X11; Linux i686) AppleWebKit/535.7 (KHTML, like Gecko) Ubuntu/11.04 Chromium/16.0.912.77 Chrome/16.0.912.77 Safari/535.7\",\n    \"Mozilla/5.0 (X11; Ubuntu; Linux i686; rv:10.0) Gecko/20100101 Firefox/10.0 \"\n]\n\n```\n\n### 切换Windows系统壁纸\n```python\nimport ctype\nctypes.windll.user32.SystemParametersInfoW(20, 0, filepath, 0)\n```\n\n### 获取系统基本信息\n```python\n\nimport psutil\nimport time\nimport datetime\n \n\"\"\"\n获取系统基本信息\n\"\"\"\n \nEXPAND = 1024 * 1024\n\ndef capacity_change(data:int):\n    print(data)\n    if data <= pow(1024,1) :\n        return str(format(data/1024,'.2f'))+\"KB\\n\"\n    elif pow(1024,2) < data and data <= pow(1024,3):\n        return str(format(data/pow(1024,2),'.2f'))+\"MB\\n\"\n    else:\n        return str(format(data/pow(1024,3),'.2f'))+\"GB\\n\"\n    \n\n\n\n\ndef mems():\n    ''' 获取系统内存使用情况 '''\n    mem = psutil.virtual_memory()\n    mem_str = \" 内存状态如下:\\n\"\n    mem_str += \"   系统的内存容量为: \" + capacity_change(mem.total)\n    mem_str += \"   系统的内存已使用容量为: \" + capacity_change(mem.used)\n    mem_str += \"   系统可用的内存容量为: \" + capacity_change(mem.total - mem.used)\n    # mem_str += \"   内存的buffer容量为: \" + str(mem.buffers / EXPAND) + \" MB\\n\"\n    # mem_str += \"   内存的cache容量为:\" + str(mem.cached / EXPAND) + \" MB\\n\"\n    return mem_str\n \n \ndef cpus():\n    ''' 获取cpu的相关信息 '''\n    cpu_str = \" CPU状态如下:\\n\"\n    cpu_status = psutil.cpu_times()\n    cpu_str += \"   user = \" + str(cpu_status.user) + \"\\n\"\n    # cpu_str += \"   nice = \" + str(cpu_status.nice) + \"\\n\"\n    cpu_str += \"   system = \" + str(cpu_status.system) + \"\\n\"\n    cpu_str += \"   idle = \" + str(cpu_status.idle) + \"\\n\"\n    # cpu_str += \"   iowait = \" + str(cpu_status.iowait) + \"\\n\"\n    # cpu_str += \"   irq = \" + str(cpu_status.irq) + \"\\n\"\n    cpu_str += \"   softirq = \" + str(cpu_status.softirq) + \"\\n\"\n    cpu_str += \"   steal = \" + str(cpu_status.steal) + \"\\n\"\n    cpu_str += \"   guest = \" + str(cpu_status.guest) + \"\\n\"\n    return cpu_str\n \n \ndef disks():\n    ''' 查看硬盘基本信息 '''\n    ''' psutil.disk_partitions()    获取磁盘的完整信息\n        psutil.disk_usage('/')      获得分区的使用情况,这边以根分区为例\n        psutil.disk_io_counters()   获取磁盘总的io个数\n        perdisk 默认为False\n        psutil.disk_io_counters(perdisk=True)   perdisk为True 返回单个分区的io个数\n    '''\n    disk_str = \" 硬盘信息如下:\\n\"\n    disk_status = psutil.disk_partitions()\n    for item in disk_status:\n        disk_str += str(item) + \"\\n\"\n        #p = item.device\n        p = item.mountpoint\n        disk = psutil.disk_usage(p)\n        disk_str += p+\"盘容量为: \" + str(disk.total / EXPAND) + \" MB\\n\"\n        disk_str += p+\"盘已使用容量为: \" + str(disk.used / EXPAND) + \" MB\\n\"\n        disk_str += p+\"盘可用的内存容量为: \" + str(disk.free / EXPAND) + \" MB\\n\"\n    return disk_str\n \n \n# def users():\n#     ''' 查看当前登录的用户信息 '''\n#     user_str = \" 登录用户信息如下:\\n \"\n#     user_status = psutil.users()\n#     for item in user_status:\n#         user_str += str(item) + \"\\n\"\n#     return user_str\n \n# def process():\n    # ''' 查看进程信息 '''\n    # pids = psutil.pids()\n    # proces = []\n    # for pid in pids:\n    #     p = psutil.Process(pid)\n    #     jctime = str(datetime.datetime.fromtimestamp(p.create_time()))[:19]\n    #     p_info = [\n    #         p.name(),       # 进程的名字\n    #         #p.exe(),        # 进程bin文件位置\n    #         #p.cwd(),        # 进程的工作目录的绝对路径\n    #         p.status(),     # 进程的状态\n    #         jctime,         # 进程的创建时间\n    #         #p.uids(),       # 进程的uid信息\n    #         #p.gids(),       # 进程的gid信息\n    #         p.cpu_times(),  # cup时间信息\n    #         p.memory_info(),# 进程内存的利用率\n    #         p.io_counters() # 进程的io读写信息\n    #     ]\n    #     proces.append(p_info)\n    # return proces\n \nif __name__ == '__main__':\n    print(mems())   # 内存\n    print(cpus())   # CPU\n    print(disks())  # 硬盘\n    # print(users())  # 登录用户\n    # proces = process()\n    # print(proces[0])\n```\n\n### 获取当前的用户信息\n```python\nf = open(\"C:\\\\Users\\\\\"+str(getpass.getuser())+\"\\\\Pictures\\\\tmp\",'a+')\n```\n\n### 常用的数据结构\n```python\n\n# coding: utf-8\n\n# ### 数据结构一般包括栈、队列、链表，这里用python来实现他们\n\n# #### 栈的特点是先进后出，只能有一端进行进出栈的操作\n\n# In[1]:\n\n\nclass Stack():\n    #预先定义栈的长度\n    def __init__(self,size):\n        self.size = size\n        self.long = 0\n        self.stack = []\n    def push(self,item):\n        if self.long < self.size :\n            self.stack.append(item)\n            self.long+=1\n            return True\n        else:\n            return False\n    def pop(self):\n        if self.long == 0:\n            return False\n        else:\n            a = self.stack[-1]\n            self.stack.pop(-1)\n            self.long-=1\n            return a\n    def geek(self):\n        return self.stack[-1]\n    def isFull(self):\n        return self.long == self.size\n\n\n#  #### 队列的特点是先进先出，有队尾插入，由队头移除\n\n# In[43]:\n\n\nclass Queue():\n    def __init__(self,size):\n        self.size = size + 1\n        self.queue = []\n        self.head = 0\n        self.tail = 0\n    def push(self,item):\n        if self.head == (self.tail + 1) % self.size:\n            return False\n        else:\n            self.queue.insert(self.tail,item)\n            self.tail = (self.tail + 1) % self.size\n            return True\n    def pop(self):\n        if self.head != self.tail:\n            a = self.queue[self.head]\n            self.queue[self.head] = None\n            self.head = (self.head +1) % self.size\n            return a\n        else:\n            return False\n    def geek(self):\n        if self.head == self.tail:\n            return False\n        else:\n            return self.queue[self.head]\n    def long(self):\n        if self.tail >= self.head:\n            return self.tail-self.head\n        else: \n            return self.tail + self.size - self.head\n    def isFull(self):\n        return self.head == (self.tail + 1) % self.size\n\n\n# #### 用栈实现队列\n# 首先定义两个栈，stack1和stack2\n# 入队时，直接把元素压入stack1中\n# 出队，如果stack2不为空，则直接弹出stack2中的元素\n# 否则，先把stack1中元素全部压入stack2中，再弹出stack2栈顶元素\n\n# In[ ]:\n\n\nclass stackToQueue():\n    def __init__(self,size):\n        self.size = size\n        self._stack1 = Stack(size)\n        self._stack2 = Stack(size)\n    def long(self):\n        return self._stack1.size() + self._stack2.size()\n    def push(self,item):\n        if self._stack1.isFull() or self.long() >= self.size:\n            return False\n        else:\n            self._stack1.push(item)\n    def pop(self):\n        if self._stack2.long != 0:\n            return self._stack2.pop()\n        else:\n            while self._stack1.long!=0 :\n                self._stack2.push(self._stack1.pop())\n            return self._stack2.pop()\n\n\n# #### 两个队列实现栈\n# 入栈，哪个队列不为空，就把元素入队到哪个队列中，如果都为空，则任选一个入队，记为queue1\n# 出栈，把不为空的队列中除最后一个元素外所有元素移动到另一个队列中，然后出队第一个元素\n\n# In[45]:\n\n\nclass queueToStack():\n    def __init__(self,size):\n        self.size = size\n        self._queue1 = Queue(size)\n        self._queue2 = Queue(size)\n    def long(self):\n        return self._queue1.long() + self._queue2.long()\n    def push(self,item):\n        if self.long() >= self.size:\n            return False\n        else:\n            if self._queue1.long() == 0:\n                self._queue1.push(item)\n            else:\n                self._queue2.push(item)\n            return True\n    def pop(self):\n        if self._queue1.long() ==0 and self._queue2.long() ==0 :\n            return False\n        if self._queue1.long() == 0:\n            while self._queue2.long() > 1:\n                self._queue1.push(self._queue2.pop())\n            return self._queue2.pop()\n        else:\n            while self._queue1.long() > 1:\n                self._queue2.push(self._queue1.pop())\n            return self._queue1.pop()\n\n\n```\n\n### 获取系统管理员权限\n需要测试几次\n```python\nfrom __future__ import print_function\nimport ctypes, sys\nimport os\ndef is_admin():\n    try:\n        print('not permiss')\n        print(__file__)\n        return ctypes.windll.shell32.IsUserAnAdmin()\n    except:\n        return False\nif is_admin():\n    src = r\"C:\\Users\\木羽\\Pictures\\1.jpg\"\n    dst = r\"C:\\Users\\木羽\\Pictures\\Camera Roll\\hello\"\n    os.symlink(src,dst)\nelse:\n    if sys.version_info[0] == 3:\n    \tctypes.windll.shell32.ShellExecuteW(None, \"runas\", sys.executable, __file__, None, 1)\n    else:#in python2.x\n        ctypes.windll.shell32.ShellExecuteW(None, u\"runas\", sys.executable.decode('utf8'), __file__.decode('utf8'), None, 1)\n```"}